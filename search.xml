<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[React]]></title>
    <url>%2F2017%2F09%2F13%2FReact%2F</url>
    <content type="text"><![CDATA[入门 一个核心思想——组件化两位带头大哥——react &amp; react-dom一个基本运作方式——数据驱动视图一位神秘卧底——jsx语法三位护法——state（状态）、props（属性）、refs（实例）一群打杂小弟——生命周期 create-React-app是一个全局的命令行工具用来创建一个新的项目react-scripts是一个生成的项目所需要的开发依赖 一般我们开始创建react应用程序的时候，要自己通过npm或者安装项目的全部依赖，再写webpack.config.js，一系列复杂的配置，搭建好开发环境后写src源代码现在如果你正在搭建react运行环境，使用create-react-app去自动构建你的程序。你的项目所在的文件夹下是没有配置文件的。react-scripts是唯一的额外的构造依赖 在你的package.json中，你的运行环境将有每一个你需要用来构建一个现代应用程序应用程序你需要依赖，在配置文件中编写的配置代码，反应脚本都帮你写了，比如：react-scripts帮你自动下载需要的webpack-dev-server依赖，然后react脚本自己写了一个nodejs服务端的脚本代码start.js来实例化WebpackDevServer，并且运行启动了一个使用express的Http服务器，现在你只需要专心写SRC源代码就可以了。省去了很多精力，最适合快速上手一个演示了。 [React-scripts有以下支持，都帮你配置好了：React，JSX，ES6和Flow语法支持。ES6之外的语言扩展像对象扩展运算符。直接从JavaScript导入CSS和图像文件。自动翻译CSS，所以你不需要-webkit或其他前缀。一个构建脚本来捆绑JS，CSS，和图像进行生产，具有源代码图。 示例：index:123456789101112131415161718192021222324252627// 1.引入两位带头大哥 react和react-domimport React from &apos;react&apos;import ReactDom from &apos;react-dom&apos;// 引入App组件 import App from &apos;./App&apos;import logo from &apos;./logo.svg&apos;// ReactDom负责控制页面的内容 但是使用ReactDom 必须依赖React// 第一个参数 是渲染的元素(必须是闭合标签) 第二个参数是渲染的位置ReactDom.render( &lt;div&gt; &lt;h1&gt;今天学习了react&lt;/h1&gt; &lt;h2&gt;这是一个h2标签&lt;/h2&gt; &lt;img src=&#123;logo&#125; alt=&quot;&quot;/&gt; &lt;App /&gt; &lt;/div&gt;, document.getElementById(&apos;root&apos;))// jsx ==== javascript +xml 神秘的卧底// 可以在js语言中 插入 xml(html)语言 语法糖 每一个XML标签都会被JSX转换工具转换成纯Javascript代码 app:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import React,&#123;Component&#125; from &apos;react&apos;import &apos;./App.css&apos;class App extends Component&#123; constructor()&#123; super() console.log(this) this.state = &#123; name:&apos;焦洋&apos;, time:(new Date()).toLocaleTimeString() &#125; setInterval(()=&gt;&#123; // 在react中 修改state 不能直接修改 必须通过调用this.setState() // 修改我们的时间 // console.log(this); this.setState(&#123; time:(new Date()).toLocaleTimeString() &#125;) &#125;,1000) &#125; say()&#123; return &apos;say Hello&apos; &#125; // 引入一个打杂的小弟 生命周期 方法 render()&#123; // var s = &apos;abc&apos; // &#123;&#125; 插值 插槽 &lt;%= %&gt; 插值即可以插变量 也可以插函数 return ( &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li className=&apos;li2&apos;&gt;&#123;3&gt;4 ? &apos;真的&apos; : &apos;假的&apos;&#125;&lt;/li&gt; &lt;li&gt;&#123;this.say()&#125;&lt;/li&gt; &lt;li&gt;&#123;111&#125;&lt;/li&gt; &lt;li&gt;&#123;this.state.name&#125;&lt;/li&gt; &lt;li&gt;&#123;this.state.time&#125;&lt;/li&gt; &lt;/ul&gt; ) &#125;&#125;//抛出 Appexport default App;]]></content>
  </entry>
  <entry>
    <title><![CDATA[gulp bower yoman]]></title>
    <url>%2F2017%2F09%2F12%2Fgulp%20bower%20yoman%2F</url>
    <content type="text"><![CDATA[不再是简简单单的使用HTML+CSS+JavaScript这些简单的技术构建网页应用程序了 我们要提高效率，就必须减少重复的工作 使用less之类预处理的CSS 提供开发阶段的便利，开发阶段更快捷 现在的开发行业优质的开发人员是不应该将精力放在这些重复性质的工作上 Gulp就是一种可以自动化完成我们开发过程中大量的重复工作 预处理语言的编译 js css html 压缩混淆 图片体积优化 除gulp之外还有一些类似的自动化工具，比如grunt 1.gulp的使用1&gt;首先使用gulp 必须全局安装gulp npm install gulp -g2&gt;测试自己电脑上已安装了gulp gulp —version3&gt;在自己项目的根目录下 安装 开发者依赖 npm install gulp —save-dev4&gt;然后在根目录下创建一个名为gulpfile.js的文件 gulpfile.js文件代码如下：var gulp = require(‘gulp’); //默认任务 第一个参数是任务的名字，第二个参数是要执行的任务gulp.task(‘default’,function(){ console.log(‘我是一个默认任务’)}) 此时在命令行中执行gulp 会默认的执行default任务 // 自定义一个任务gulp.task(‘hello’,function(){ console.log(‘Hello world’)}) 此时在命令行中执行gulp hello，会打印Hello world证明任务已执行 gulp的作用在上面有介绍，有几个常用的插件：（去npm上搜索关键字寻找） • 编译 Jade: gulp-jade • 创建本地服务器：gulp-connect • 合并文件：gulp-concat • 最小化 js 文件：gulp-uglify • 重命名文件：gulp-rename • 最小化 css 文件：gulp-minify-css • 压缩html文件 gulp-minify-html • 最小化图像：gulp-imagemin 自行练习上面插件的用法。 2.browser-sync的使用仅仅的靠gulp的这点作用还不够，比如nodejs中有supervisor 只要后台代码发生改变，就能看到变化，那么前端就没有那种工具吗？答案是有的 ====browser-sync 它叫浏览器同步官网：https://www.browsersync.io/ 使用bowser-sync 全局安装 npm install -g bowser-sync在根目录下创建一个index.html文件然后执行以下命令browser-sync start –server –files “.html”后面”.html” 是匹配文件的路径，使用正则表达式匹配 然后将bowser-sync集成到gulp中去使用http://www.browsersync.cn/docs/gulp/#gulp-sass-css用法：在之前的gulpfile.js文件中写入 123456789101112131415var browserSync = require(&apos;browser-sync&apos;).create();var reload = browserSync.reload;//先执行style任务 后执行serve任务gulp.task(&apos;serve&apos;, [&apos;style&apos;], function() &#123; browserSync.init(&#123; server: &quot;./&quot; &#125;); gulp.watch(&quot;./src/style/*.css&quot;, [&apos;style&apos;]); gulp.watch(&quot;./*.html&quot;).on(&apos;change&apos;, reload);&#125;);//然后执行任务gulp serve 3.bower的使用 后端有npm管理包工具,前端有bower管理包工具 老套路 npm install bower -g 然后windows电脑 请使用cmd执行以下命令，不要使用gitbash了，会出问题（切记） bower init 初始化，会生成一个 bower.json的文件 bower install bootstrap –save 跟npm 用法类似 上面讲述了 gulp(代码压缩，图片压缩，混淆等等) bowser-sync（代码与浏览器同步） bower（前端包管理工具），或许会有一种工具能将三种工具集成一起起作用。那就是yoman http://yeoman.io/ yoman可以一键生成我们的前端的项目代码，集成了gulp bowser-sync bower三种工具的好处，好用之及。要想使用yomannpm install yo -g 安装一个全局的发电机 注意是一个 generator有很多个，可以去官网上查找npm install -g generator-webapp 然后windows电脑用户注意了，以下命令请在cmd中使用 执行 yo上下键选择webapp空格键去掉不想使用的库然后启动gulp serve来查看一下当前生成的项目，修改一下里面的代码，保存，看一下bowser-sync的作用然后执行gulp 会执行default任务，查看一下当前目录会生成一个dist文件夹，里面就是被处理之后的项目代码。]]></content>
  </entry>
  <entry>
    <title><![CDATA[cookie&session]]></title>
    <url>%2F2017%2F09%2F12%2Fcookie_session%2F</url>
    <content type="text"><![CDATA[在web应用中，多个请求之间共享“用户会话”是非常必要的。但HTTP1.0协议是无状态的。那这时Cookie就出现了。那Cookie又是如何处理的呢？ Cookie的处理： 服务端向客户端发送Cookie 客户端的浏览器把Cookie保存 然后在每次请求浏览器都会将Cookie发送到服务端 在HTML文档被发送之前，Web服务器通过传送HTTP 包头中的Set-Cookie 消息把一个cookie 发送到用户的浏览器中，如下示例：Set-Cookie: name=value; Path=/; expires=Wednesday, 09-Nov-99 23:12:40 GMT; 其中比较重要的属性： name=value：键值对，可以设置要保存的 Key/Value，注意这里的 name 不能和其他属性项的名字一样Expires： 过期时间（秒），在设置的某个时间点后该 Cookie 就会失效，如 expires=Wednesday, 09-Nov-99 23:12:40 GMTmaxAge： 最大失效时间（毫秒），设置在多少后失效secure： 当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效Path： 表示 cookie 影响到的路，如 path=/。如果路径不能匹配时，浏览器则不发送这个Cookie cookie在express中的使用express 在 4.x 版本之后，管理session和cookies等许多模块都不再直接包含在express中， `而是需要单独下载安装相应模块。 cookieParser安装：$ npm install cookie-parser 通过express命令创建的项目会自动将这个模块安装。 session什么是session？ session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而session保存在服务器上。 客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是session。客户端浏览器再次访问时只需要从该Session中查找该客户的状态就可以了。 如果说Cookie机制是通过检查客户身上的“通行证”来确定客户身份的话，那么session机制就是通过检查服务器上的“客户明细表”来确认客户身份。 session相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。 两者的区别： cookie数据存放在客户的浏览器上，session数据放在服务器上。cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗 考虑到安全应当使用session。session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能 考虑到减轻服务器性能方面，应当使用COOKIE。单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。所以建议：将登陆信息等重要信息存放为session、其他信息如果需要保留，可以放在cookie中 ####express中的session 跟cookie一样都需要单独的安装和引用模块， 安装模块： $npm install express-session这个模块没有默认安装，需要自己手动安装，并引入：var session = require(‘express-session’);这个模块的主要的方法是 session(options)，其中 options 中包含可选参数，主要有： name: 设置 cookie 中，保存 session 的字段名称，默认为 connect.sid 。store: session 的存储方式，默认存放在内存中，也可以使用 redis，mongodb 等。express生态中都有相应模块的支持。secret: 通过设置的 secret 字符串，来计算 hash 值并放在 cookie 中，使产生的 signedCookie防篡改。cookie: 设置存放 session id 的 cookie 的相关选项，默认为 (default: { path: ‘/’,httpOnly: true, secure: false, maxAge: null })genid: 产生一个新的 session_id 时，所使用的函数， 默认使用 uid2 这个 npm 包。rolling: 每个请求都重新设置一个 cookie，默认为 false。resave: 即使 session 没有被修改，也保存 session 值，默认为 true。]]></content>
  </entry>
  <entry>
    <title><![CDATA[this指针]]></title>
    <url>%2F2017%2F09%2F12%2F7.13%20JS-8.%20this%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[一、this指针 this就是js中的当前行为主体 全局中的this是window 函数中的this要看函数执行的时候前面有没有“.”,如果有点 点前面是谁this就是谁。如果没有点 this就是windowPS:如果访问对象的属性 但是这个属性不存在返回undefined获取一个不存在的元素返回的是null定义在哪里没有关系 主要看执行的时候123456789 function fn()&#123; console.log(this); // obj&#125;var obj=&#123;fn:fn,name:&apos;that&apos;&#125;;function f()&#123; console.log(this) //window obj.fn()&#125; 函数中的this和函数在哪执行和在哪里定义都没有任何关系 自执行函数里面的this永远是window 给元素绑定事件 事件触发的时候 里面的this就是当前绑定事件的元素 1234567btn.onclick = function()&#123; console.log(this); //btn fn() //虽然在 事件里执行 但是要看前面有没有点&#125;function fn()&#123; console.log(this) //window&#125; 定时器里面的this也是window 类中的this 指的是当前实例 改变this的方法：call apply bind #####练习：12345678910111213141516171819202122232425262728293031function fn1()&#123; conslo.log(this); // ary &#125; function fn2()&#123; conslo.log(this); &#125; var ary = [fn1,fn2]ary[1]() // ary[1] = ary.1\\ var num = 5; // 6 -&gt; 7 var obj = &#123; num : 4, // 5 fn : (function (num)&#123; num++; this.num++; // 自执行函数中this window window.num++ 6 var num = 2; // num = 2 -&gt; 3 -&gt; 4 return function ()&#123; num++; // 2++ -&gt; 3++ this.num++; // window.num++ 6++ // obj.num++ 4++ console.log(num); // 3 // 4 &#125; &#125;)() &#125;; var fn = obj.fn; fn(); // 3 obj.fn(); // 4 console.log(this.num,obj.num); // 7 5 二、单例模式 ：把描述同一个事物（或者同一个对象）放在一个内存空间，起到分组的作用即使对象的属性名相同也不会产生冲突“模块化开发”：项目中开发的模块比较多的时候，多人协作，每个人负责一个模块 最终把代码合并到一起的 单例模式中把 flightFn 和 trainFn 称为命名空间其实就是对象高级单例模式：定义一个自运行函数，返回值是一个对象。 12345678910111213141516var flightFn = &#123; title:机票, mess:‘欢迎来到平台买机票’, say:function()&#123; alert(this.title+this.mess) &#125; &#125;flightFn.say(); var trainFn = &#123; title:火车票, mess:‘欢迎来到平台买火车票’, say:function()&#123; alert(this.title+this.mess) &#125; &#125; trainFn.say(); 三、工厂模式： 把实现一个功能的代码放到一个函数里面 减少冗余的代码—-&gt; 函数封装 高内聚低耦合：减少页面中重复代码 提升代码重复利用率。特点： 四、面向对象 对象：是一个泛指 比如自然界类：对对象的具体细分，比如 植物类 动物类 人类实例：类中某一个具体事物 比如某一个人类的 封装 继承 多态继承： 子类继承父类多态：多种形态（重载和重写）JS中没有重载重写：子类重写父类对象的遍历：for(var key in obj){}对象的__proto__指向所属类的原型函数有三种角色：函数，类，对象 五、构造函数类本身也是个函数，特点： 1.一般约定函数名首字母大写2.不用手动创建对象 用this3.没有return 直接会返回一个对象作为这个类的实例4 执行的时候要用new 12345678function CreatePerson(name,age)&#123;// 执行之前，浏览器默认创建一个对象 this.name = name; // 在类的是this.xxx是个当前实例添加属性 this.age = age; // 给当前实例添加私有属性// 默认将这个对象返回 &#125;var person1 = new CreatePerson(&apos;zhangsan&apos;,10); // 构造函数模式，执行 他的返回值就是这个类的实例console.log(person1) 工厂模式和构造函数模式对比*1.工厂模式是普通函数执行 构造函数通过new来执行 默认创建一个对象 将其返回作为这个类的实例2.执行的时候形成一个私有作用域 –&gt; 形参赋值—-&gt;预解释—-&gt;代码 从上至下构造函数模式执行的时候 会默认创建一个对象 默认返回的实例 工厂模式手工创建每一个实例都是一个独立的个体 Object 基类instanceof 用来检测一个实例数否属于这个类1person1 instanceof CreatePerson //turn Ps : 如果构造函数有return 的是一个引用数据类型 就会把之前的对象覆盖如果返回的是一个基本数据类型的话 那就没有影响 123456789101112131415161718192021222324function CreatePerson(name,age)&#123; this.name = name; this.age = age; return &#123; info : &apos;hahaha&apos;&#125; // return 124 // 基本数据类型就不会有影响 &#125;var person1 = new CreatePerson(&apos;zhangsan&apos;,10); console.log(person1) // hahaha var num = 1; // --3 --5 var obj = &#123;num : 2&#125;; // 4 obj.fn = (function (num)&#123; // 1 this.num += 2; num--; // 0--- -1 -- 0-- -1 return function (n)1 // 2 this.num += 2; num--; console.log(n + ++num); // 1+0 &#125; &#125;)(this.num); var fn = obj.fn; fn(1); // 1 obj.fn(2); // 2 console.log(num,obj.num); // 5 4 自执行函数只执行一次两次this.num 代表的不一样 第一次是 window 第二次是obj123456789101112131415161718var num = 20; 60 240 var obj = &#123; num: 30, 120 fn: (function (num) &#123;20 this.num *= 3; num += 15; 35 var num = 45; 45 65 85 return function () &#123; this.num *= 4; num += 20; 65 console.log(num); 65 &#125; &#125;)(num) &#125;; var fn = obj.fn; fn(); 65 obj.fn(); 85 console.log(window.num, obj.num); 240 120 在构造函数中，如果不需要传参，就可以省略小括号var f1 = new Fn; 类有普通函数的一面，当函数执行的时候， var num 其实只是当前形成的私有作用域中的私有变量而已， 和实例没有任何关系 检测一个实例是否属于某一个类 instanceof每一个实例都是对象数据类型 检测某一个属性数否属于一个对象 用Iinattr in object 不管是共有的属性还是私有的属性都可以检测 hasOwnProperty: 用来检测某一个属性是否是这个对象的私有属性f1.hasOwnProperty(‘getX’)]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F09%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
